// -*- C++ -*-
//===-------------------------- hq_memory ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_HQ_MEMORY
#define _LIBCPP_HQ_MEMORY

/*
    memory synopsis

namespace std
{

template <class Y> struct hq_auto_ptr_ref {};      // deprecated in C++11,
removed in C++17

template<class X>
class hq_auto_ptr                                  // deprecated in C++11,
removed in C++17
{
public:
    typedef X element_type;

    explicit hq_auto_ptr(X* p =0) throw();
    hq_auto_ptr(hq_auto_ptr&) throw();
    template<class Y> hq_auto_ptr(hq_auto_ptr<Y>&) throw();
    hq_auto_ptr& operator=(hq_auto_ptr&) throw();
    template<class Y> hq_auto_ptr& operator=(hq_auto_ptr<Y>&) throw();
    hq_auto_ptr& operator=(auto_ptr_ref<X> r) throw();
    ~hq_auto_ptr() throw();

    typename add_lvalue_reference<X>::type operator*() const throw();
    X* operator->() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    hq_auto_ptr(auto_ptr_ref<X>) throw();
    template<class Y> operator auto_ptr_ref<Y>() throw();
    template<class Y> operator hq_auto_ptr<Y>() throw();
};

template <class T, class D = default_delete<T>>
class hq_unique_ptr
{
public:
    typedef see below pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr hq_unique_ptr() noexcept;
    explicit hq_unique_ptr(pointer p) noexcept;
    hq_unique_ptr(pointer p, see below d1) noexcept;
    hq_unique_ptr(pointer p, see below d2) noexcept;
    hq_unique_ptr(hq_unique_ptr&& u) noexcept;
    hq_unique_ptr(nullptr_t) noexcept : hq_unique_ptr() { }
    template <class U, class E>
        hq_unique_ptr(hq_unique_ptr<U, E>&& u) noexcept;
    template <class U>
        hq_unique_ptr(hq_auto_ptr<U>&& u) noexcept;       // removed in C++17

    // destructor
    ~hq_unique_ptr();

    // assignment
    hq_unique_ptr& operator=(hq_unique_ptr&& u) noexcept;
    template <class U, class E> hq_unique_ptr& operator=(hq_unique_ptr<U, E>&&
u) noexcept; hq_unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    typename add_lvalue_reference<T>::type operator*() const;
    pointer operator->() const noexcept;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void swap(hq_unique_ptr& u) noexcept;
};

template <class T, class D>
class hq_unique_ptr<T[], D>
{
public:
    typedef implementation-defined pointer;
    typedef T element_type;
    typedef D deleter_type;

    // constructors
    constexpr hq_unique_ptr() noexcept;
    explicit hq_unique_ptr(pointer p) noexcept;
    hq_unique_ptr(pointer p, see below d) noexcept;
    hq_unique_ptr(pointer p, see below d) noexcept;
    hq_unique_ptr(hq_unique_ptr&& u) noexcept;
    hq_unique_ptr(nullptr_t) noexcept : hq_unique_ptr() { }

    // destructor
    ~hq_unique_ptr();

    // assignment
    hq_unique_ptr& operator=(hq_unique_ptr&& u) noexcept;
    hq_unique_ptr& operator=(nullptr_t) noexcept;

    // observers
    T& operator[](size_t i) const;
    pointer get() const noexcept;
    deleter_type& get_deleter() noexcept;
    const deleter_type& get_deleter() const noexcept;
    explicit operator bool() const noexcept;

    // modifiers
    pointer release() noexcept;
    void reset(pointer p = pointer()) noexcept;
    void reset(nullptr_t) noexcept;
    template <class U> void reset(U) = delete;
    void swap(hq_unique_ptr& u) noexcept;
};

template <class T, class D>
    void swap(hq_unique_ptr<T, D>& x, hq_unique_ptr<T, D>& y) noexcept;

template <class T1, class D1, class T2, class D2>
    bool operator==(const hq_unique_ptr<T1, D1>& x, const hq_unique_ptr<T2, D2>&
y); template <class T1, class D1, class T2, class D2> bool operator!=(const
hq_unique_ptr<T1, D1>& x, const hq_unique_ptr<T2, D2>& y); template <class T1,
class D1, class T2, class D2> bool operator<(const hq_unique_ptr<T1, D1>& x,
const hq_unique_ptr<T2, D2>& y); template <class T1, class D1, class T2, class
D2> bool operator<=(const hq_unique_ptr<T1, D1>& x, const hq_unique_ptr<T2, D2>&
y); template <class T1, class D1, class T2, class D2> bool operator>(const
hq_unique_ptr<T1, D1>& x, const hq_unique_ptr<T2, D2>& y); template <class T1,
class D1, class T2, class D2> bool operator>=(const hq_unique_ptr<T1, D1>& x,
const hq_unique_ptr<T2, D2>& y);

template <class T, class D>
    bool operator==(const hq_unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator==(nullptr_t, const hq_unique_ptr<T, D>& y) noexcept;
template <class T, class D>
    bool operator!=(const hq_unique_ptr<T, D>& x, nullptr_t) noexcept;
template <class T, class D>
    bool operator!=(nullptr_t, const hq_unique_ptr<T, D>& y) noexcept;

template <class T, class D>
    bool operator<(const hq_unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<(nullptr_t, const hq_unique_ptr<T, D>& y);
template <class T, class D>
    bool operator<=(const hq_unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator<=(nullptr_t, const hq_unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>(const hq_unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>(nullptr_t, const hq_unique_ptr<T, D>& y);
template <class T, class D>
    bool operator>=(const hq_unique_ptr<T, D>& x, nullptr_t);
template <class T, class D>
    bool operator>=(nullptr_t, const hq_unique_ptr<T, D>& y);

class bad_hq_weak_ptr
    : public std::exception
{
    bad_hq_weak_ptr() noexcept;
};

template<class T, class... Args> hq_unique_ptr<T> make_hq_unique(Args&&...
args);     // C++14 template<class T>                hq_unique_ptr<T>
make_hq_unique(size_t n);           // C++14 template<class T, class... Args>
unspecified   make_hq_unique(Args&&...) = delete; // C++14, T == U[N]

template<class E, class T, class Y, class D>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, hq_unique_ptr<Y,
D> const& p);

template<class T>
class hq_shared_ptr
{
public:
    typedef T element_type;
    typedef hq_weak_ptr<T> weak_type; // C++17

    // constructors:
    constexpr hq_shared_ptr() noexcept;
    template<class Y> explicit hq_shared_ptr(Y* p);
    template<class Y, class D> hq_shared_ptr(Y* p, D d);
    template<class Y, class D, class A> hq_shared_ptr(Y* p, D d, A a);
    template <class D> hq_shared_ptr(nullptr_t p, D d);
    template <class D, class A> hq_shared_ptr(nullptr_t p, D d, A a);
    template<class Y> hq_shared_ptr(const hq_shared_ptr<Y>& r, T *p) noexcept;
    hq_shared_ptr(const hq_shared_ptr& r) noexcept;
    template<class Y> hq_shared_ptr(const hq_shared_ptr<Y>& r) noexcept;
    hq_shared_ptr(hq_shared_ptr&& r) noexcept;
    template<class Y> hq_shared_ptr(hq_shared_ptr<Y>&& r) noexcept;
    template<class Y> explicit hq_shared_ptr(const hq_weak_ptr<Y>& r);
    template<class Y> hq_shared_ptr(hq_auto_ptr<Y>&& r);          // removed in
C++17 template <class Y, class D> hq_shared_ptr(hq_unique_ptr<Y, D>&& r);
    hq_shared_ptr(nullptr_t) : hq_shared_ptr() { }

    // destructor:
    ~hq_shared_ptr();

    // assignment:
    hq_shared_ptr& operator=(const hq_shared_ptr& r) noexcept;
    template<class Y> hq_shared_ptr& operator=(const hq_shared_ptr<Y>& r)
noexcept; hq_shared_ptr& operator=(hq_shared_ptr&& r) noexcept; template<class
Y> hq_shared_ptr& operator=(hq_shared_ptr<Y>&& r); template<class Y>
hq_shared_ptr& operator=(hq_auto_ptr<Y>&& r); // removed in C++17 template
<class Y, class D> hq_shared_ptr& operator=(hq_unique_ptr<Y, D>&& r);

    // modifiers:
    void swap(hq_shared_ptr& r) noexcept;
    void reset() noexcept;
    template<class Y> void reset(Y* p);
    template<class Y, class D> void reset(Y* p, D d);
    template<class Y, class D, class A> void reset(Y* p, D d, A a);

    // observers:
    T* get() const noexcept;
    T& operator*() const noexcept;
    T* operator->() const noexcept;
    long use_count() const noexcept;
    bool unique() const noexcept;
    explicit operator bool() const noexcept;
    template<class U> bool owner_before(hq_shared_ptr<U> const& b) const
noexcept; template<class U> bool owner_before(hq_weak_ptr<U> const& b) const
noexcept;
};

// hq_shared_ptr comparisons:
template<class T, class U>
    bool operator==(hq_shared_ptr<T> const& a, hq_shared_ptr<U> const& b)
noexcept; template<class T, class U> bool operator!=(hq_shared_ptr<T> const& a,
hq_shared_ptr<U> const& b) noexcept; template<class T, class U> bool
operator<(hq_shared_ptr<T> const& a, hq_shared_ptr<U> const& b) noexcept;
template<class T, class U>
    bool operator>(hq_shared_ptr<T> const& a, hq_shared_ptr<U> const& b)
noexcept; template<class T, class U> bool operator<=(hq_shared_ptr<T> const& a,
hq_shared_ptr<U> const& b) noexcept; template<class T, class U> bool
operator>=(hq_shared_ptr<T> const& a, hq_shared_ptr<U> const& b) noexcept;

template <class T>
    bool operator==(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator==(nullptr_t, const hq_shared_ptr<T>& y) noexcept;
template <class T>
    bool operator!=(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator!=(nullptr_t, const hq_shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
bool operator<(nullptr_t, const hq_shared_ptr<T>& y) noexcept;
template <class T>
    bool operator<=(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator<=(nullptr_t, const hq_shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>(nullptr_t, const hq_shared_ptr<T>& y) noexcept;
template <class T>
    bool operator>=(const hq_shared_ptr<T>& x, nullptr_t) noexcept;
template <class T>
    bool operator>=(nullptr_t, const hq_shared_ptr<T>& y) noexcept;

// hq_shared_ptr specialized algorithms:
template<class T> void swap(hq_shared_ptr<T>& a, hq_shared_ptr<T>& b) noexcept;

// hq_shared_ptr casts:
template<class T, class U>
    hq_shared_ptr<T> static_pointer_cast(hq_shared_ptr<U> const& r) noexcept;
template<class T, class U>
    hq_shared_ptr<T> dynamic_pointer_cast(hq_shared_ptr<U> const& r) noexcept;
template<class T, class U>
    hq_shared_ptr<T> const_pointer_cast(hq_shared_ptr<U> const& r) noexcept;

// hq_shared_ptr I/O:
template<class E, class T, class Y>
    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, hq_shared_ptr<Y>
const& p);

// hq_shared_ptr get_deleter:
template<class D, class T> D* get_deleter(hq_shared_ptr<T> const& p) noexcept;

template<class T, class... Args>
    hq_shared_ptr<T> make_hq_shared(Args&&... args);
template<class T, class A, class... Args>
    hq_shared_ptr<T> allocate_shared(const A& a, Args&&... args);

template<class T>
class hq_weak_ptr
{
public:
    typedef T element_type;

    // constructors
    constexpr hq_weak_ptr() noexcept;
    template<class Y> hq_weak_ptr(hq_shared_ptr<Y> const& r) noexcept;
    hq_weak_ptr(hq_weak_ptr const& r) noexcept;
    template<class Y> hq_weak_ptr(hq_weak_ptr<Y> const& r) noexcept;
    hq_weak_ptr(hq_weak_ptr&& r) noexcept;                      // C++14
    template<class Y> hq_weak_ptr(hq_weak_ptr<Y>&& r) noexcept; // C++14

    // destructor
    ~hq_weak_ptr();

    // assignment
    hq_weak_ptr& operator=(hq_weak_ptr const& r) noexcept;
    template<class Y> hq_weak_ptr& operator=(hq_weak_ptr<Y> const& r) noexcept;
    template<class Y> hq_weak_ptr& operator=(hq_shared_ptr<Y> const& r)
noexcept; hq_weak_ptr& operator=(hq_weak_ptr&& r) noexcept; // C++14
    template<class Y> hq_weak_ptr& operator=(hq_weak_ptr<Y>&& r) noexcept; //
C++14

    // modifiers
    void swap(hq_weak_ptr& r) noexcept;
    void reset() noexcept;

    // observers
    long use_count() const noexcept;
    bool expired() const noexcept;
    hq_shared_ptr<T> lock() const noexcept;
    template<class U> bool owner_before(hq_shared_ptr<U> const& b) const
noexcept; template<class U> bool owner_before(hq_weak_ptr<U> const& b) const
noexcept;
};

// hq_weak_ptr specialized algorithms:
template<class T> void swap(hq_weak_ptr<T>& a, hq_weak_ptr<T>& b) noexcept;

// class owner_less:
template<class T> struct owner_less;

template<class T>
struct owner_less<hq_shared_ptr<T> >
    : binary_function<hq_shared_ptr<T>, hq_shared_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(hq_shared_ptr<T> const&, hq_shared_ptr<T> const&) const
noexcept; bool operator()(hq_shared_ptr<T> const&, hq_weak_ptr<T> const&) const
noexcept; bool operator()(hq_weak_ptr<T> const&, hq_shared_ptr<T> const&) const
noexcept;
};

template<class T>
struct owner_less<hq_weak_ptr<T> >
    : binary_function<hq_weak_ptr<T>, hq_weak_ptr<T>, bool>
{
    typedef bool result_type;
    bool operator()(hq_weak_ptr<T> const&, hq_weak_ptr<T> const&) const
noexcept; bool operator()(hq_shared_ptr<T> const&, hq_weak_ptr<T> const&) const
noexcept; bool operator()(hq_weak_ptr<T> const&, hq_shared_ptr<T> const&) const
noexcept;
};

template <>  // Added in C++14
struct owner_less<void>
{
    template <class _Tp, class _Up>
    bool operator()( hq_shared_ptr<_Tp> const& __x, hq_shared_ptr<_Up> const&
__y) const noexcept; template <class _Tp, class _Up> bool operator()(
hq_shared_ptr<_Tp> const& __x,   hq_weak_ptr<_Up> const& __y) const noexcept;
    template <class _Tp, class _Up>
    bool operator()(   hq_weak_ptr<_Tp> const& __x, hq_shared_ptr<_Up> const&
__y) const noexcept; template <class _Tp, class _Up> bool operator()(
hq_weak_ptr<_Tp> const& __x,   hq_weak_ptr<_Up> const& __y) const noexcept;

    typedef void is_transparent;
};

template<class T>
class hq_enable_shared_from_this
{
protected:
    constexpr hq_enable_shared_from_this() noexcept;
    hq_enable_shared_from_this(hq_enable_shared_from_this const&) noexcept;
    hq_enable_shared_from_this& operator=(hq_enable_shared_from_this const&)
noexcept; ~hq_enable_shared_from_this(); public: hq_shared_ptr<T>
shared_from_this(); hq_shared_ptr<T const> shared_from_this() const;
};

template<class T>
    bool atomic_is_lock_free(const hq_shared_ptr<T>* p);
template<class T>
    hq_shared_ptr<T> atomic_load(const hq_shared_ptr<T>* p);
template<class T>
    hq_shared_ptr<T> atomic_load_explicit(const hq_shared_ptr<T>* p,
memory_order mo); template<class T> void atomic_store(hq_shared_ptr<T>* p,
hq_shared_ptr<T> r); template<class T> void
atomic_store_explicit(hq_shared_ptr<T>* p, hq_shared_ptr<T> r, memory_order mo);
template<class T>
    hq_shared_ptr<T> atomic_exchange(hq_shared_ptr<T>* p, hq_shared_ptr<T> r);
template<class T>
    hq_shared_ptr<T>
    atomic_exchange_explicit(hq_shared_ptr<T>* p, hq_shared_ptr<T> r,
memory_order mo); template<class T> bool
    atomic_compare_exchange_weak(hq_shared_ptr<T>* p, hq_shared_ptr<T>* v,
hq_shared_ptr<T> w); template<class T> bool atomic_compare_exchange_strong(
hq_shared_ptr<T>* p, hq_shared_ptr<T>* v, hq_shared_ptr<T> w); template<class T>
    bool
    atomic_compare_exchange_weak_explicit(hq_shared_ptr<T>* p, hq_shared_ptr<T>*
v, hq_shared_ptr<T> w, memory_order success, memory_order failure);
template<class T>
    bool
    atomic_compare_exchange_strong_explicit(hq_shared_ptr<T>* p,
hq_shared_ptr<T>* v, hq_shared_ptr<T> w, memory_order success, memory_order
failure);
// Hash support
template <class T> struct hash;
template <class T, class D> struct hash<hq_unique_ptr<T, D> >;
template <class T> struct hash<hq_shared_ptr<T> >;

template <class T, class Alloc>
  inline constexpr bool uses_allocator_v = uses_allocator<T, Alloc>::value;

}  // std

*/

#include <memory>

#include <hq_defs>
#include <hq_iosfwd>
#include <hq_wrapper>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp>
struct _LIBCPP_DEPRECATED_IN_CXX11 hq_auto_ptr_ref {
  hq_wrapper<_Tp*> __ptr_;
};

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 hq_auto_ptr {
private:
  hq_wrapper<_Tp*> __ptr_;

public:
  typedef _Tp element_type;

  _LIBCPP_INLINE_VISIBILITY explicit hq_auto_ptr(_Tp* __p = 0) throw()
      : __ptr_(__p) {}
  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr(hq_auto_ptr& __p) throw()
      : __ptr_(__p.release()) {}
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr(hq_auto_ptr<_Up>& __p) throw()
      : __ptr_(__p.release()) {}
  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr& operator=(hq_auto_ptr& __p) throw() {
    reset(__p.release());
    return *this;
  }
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr&
  operator=(hq_auto_ptr<_Up>& __p) throw() {
    reset(__p.release());
    return *this;
  }
  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr&
  operator=(hq_auto_ptr_ref<_Tp> __p) throw() {
    reset(__p.__ptr_);
    return *this;
  }
  _LIBCPP_INLINE_VISIBILITY ~hq_auto_ptr() throw() { delete __ptr_; }

  _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw() { return *__ptr_; }
  _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() { return __ptr_; }
  _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() { return __ptr_; }
  _LIBCPP_INLINE_VISIBILITY _Tp* release() throw() {
    _Tp* __t = __ptr_;
    __ptr_ = 0;
    return __t;
  }
  _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw() {
    if (__ptr_ != __p)
      delete __ptr_;
    __ptr_ = __p;
  }

  _LIBCPP_INLINE_VISIBILITY hq_auto_ptr(auto_ptr_ref<_Tp> __p) throw()
      : __ptr_(__p.__ptr_) {}
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw() {
    auto_ptr_ref<_Up> __t;
    __t.__ptr_ = release();
    return __t;
  }
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY operator hq_auto_ptr<_Up>() throw() {
    return hq_auto_ptr<_Up>(release());
  }
};

template <>
class _LIBCPP_TEMPLATE_VIS _LIBCPP_DEPRECATED_IN_CXX11 hq_auto_ptr<void> {
public:
  typedef void element_type;
};
#endif

template <class _Deleter>
struct __hq_unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __hq_unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __hq_unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class _LIBCPP_TEMPLATE_VIS hq_unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef _LIBCPP_NODEBUG_TYPE
      typename __pointer_type<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<hq_wrapper<pointer>, deleter_type> __ptr_;

  struct __nat {
    int __for_bool_;
  };

  typedef _LIBCPP_NODEBUG_TYPE __hq_unique_ptr_deleter_sfinae<_Dp>
      _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible _LIBCPP_NODEBUG_TYPE =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible _LIBCPP_NODEBUG_TYPE =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible _LIBCPP_NODEBUG_TYPE = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value>::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible _LIBCPP_NODEBUG_TYPE = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable =
      typename enable_if<is_assignable<_Dp&, _UDel&&>::value>::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR hq_unique_ptr() _NOEXCEPT
      : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR hq_unique_ptr(nullptr_t) _NOEXCEPT
      : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  _LIBCPP_INLINE_VISIBILITY explicit hq_unique_ptr(pointer __p) _NOEXCEPT
      : __ptr_(__p) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(pointer __p,
                                          _LValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(__p, _VSTD::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(pointer __p,
                                          _BadRValRefType<_Dummy> __d) = delete;

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(hq_unique_ptr&& __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<hq_unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(hq_unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(
      hq_auto_ptr<_Up>&& __p,
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         __nat>::type = __nat()) _NOEXCEPT
      : __ptr_(__p.release()) {}
#endif

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr& operator=(hq_unique_ptr&& __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<hq_unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr&
  operator=(hq_unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());
    return *this;
  }

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY
      typename enable_if<is_convertible<_Up*, _Tp*>::value &&
                             is_same<_Dp, default_delete<_Tp> >::value,
                         hq_unique_ptr&>::type
      operator=(hq_auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }
#endif

#ifdef _LIBCPP_CXX03_LANG
  hq_unique_ptr(hq_unique_ptr const&) = delete;
  hq_unique_ptr& operator=(hq_unique_ptr const&) = delete;
#endif

  _LIBCPP_INLINE_VISIBILITY
  ~hq_unique_ptr() { reset(); }

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr& operator=(nullptr_t) _NOEXCEPT {
    reset();
    return *this;
  }

  _LIBCPP_INLINE_VISIBILITY
  typename add_lvalue_reference<_Tp>::type operator*() const {
    return *__ptr_.first();
  }
  _LIBCPP_INLINE_VISIBILITY
  pointer operator->() const _NOEXCEPT { return __ptr_.first(); }
  _LIBCPP_INLINE_VISIBILITY
  pointer get() const _NOEXCEPT { return __ptr_.first(); }
  _LIBCPP_INLINE_VISIBILITY
  deleter_type& get_deleter() _NOEXCEPT { return __ptr_.second(); }
  _LIBCPP_INLINE_VISIBILITY
  const deleter_type& get_deleter() const _NOEXCEPT { return __ptr_.second(); }
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
    return __ptr_.first() != nullptr;
  }

  _LIBCPP_INLINE_VISIBILITY
  pointer release() _NOEXCEPT {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  _LIBCPP_INLINE_VISIBILITY
  void reset(pointer __p = pointer()) _NOEXCEPT {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  _LIBCPP_INLINE_VISIBILITY
  void swap(hq_unique_ptr& __u) _NOEXCEPT { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp>
class _LIBCPP_TEMPLATE_VIS hq_unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<hq_wrapper<pointer>, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<
            bool,
            is_same<_FromElem*, pointer>::value ||
                (is_same<pointer, element_type*>::value &&
                 is_convertible<_FromElem (*)[], element_type (*)[]>::value)> {
  };

  typedef __hq_unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType _LIBCPP_NODEBUG_TYPE =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible _LIBCPP_NODEBUG_TYPE =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible _LIBCPP_NODEBUG_TYPE =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible _LIBCPP_NODEBUG_TYPE =
      typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type;

  template <class _UPtr, class _Up, class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible _LIBCPP_NODEBUG_TYPE = typename enable_if<
      is_array<_Up>::value && is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT (*)[], element_type (*)[]>::value>::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible _LIBCPP_NODEBUG_TYPE = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable _LIBCPP_NODEBUG_TYPE =
      typename enable_if<is_assignable<_Dp&, _UDel&&>::value>::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR hq_unique_ptr() _NOEXCEPT
      : __ptr_(pointer()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR hq_unique_ptr(nullptr_t) _NOEXCEPT
      : __ptr_(pointer()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  _LIBCPP_INLINE_VISIBILITY explicit hq_unique_ptr(_Pp __p) _NOEXCEPT
      : __ptr_(__p) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(_Pp __p,
                                          _LValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(nullptr_t,
                                          _LValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(__p, _VSTD::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) _NOEXCEPT
      : __ptr_(nullptr, _VSTD::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr(_Pp __p,
                                          _BadRValRefType<_Dummy> __d) = delete;

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(hq_unique_ptr&& __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {
  }

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr& operator=(hq_unique_ptr&& __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<hq_unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr(hq_unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT
      : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<hq_unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  _LIBCPP_INLINE_VISIBILITY hq_unique_ptr&
  operator=(hq_unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {
    reset(__u.release());
    __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());
    return *this;
  }

#ifdef _LIBCPP_CXX03_LANG
  hq_unique_ptr(hq_unique_ptr const&) = delete;
  hq_unique_ptr& operator=(hq_unique_ptr const&) = delete;
#endif

public:
  _LIBCPP_INLINE_VISIBILITY
  ~hq_unique_ptr() { reset(); }

  _LIBCPP_INLINE_VISIBILITY
  hq_unique_ptr& operator=(nullptr_t) _NOEXCEPT {
    reset();
    return *this;
  }

  _LIBCPP_INLINE_VISIBILITY
  typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  _LIBCPP_INLINE_VISIBILITY
  pointer get() const _NOEXCEPT { return __ptr_.first(); }

  _LIBCPP_INLINE_VISIBILITY
  deleter_type& get_deleter() _NOEXCEPT { return __ptr_.second(); }

  _LIBCPP_INLINE_VISIBILITY
  const deleter_type& get_deleter() const _NOEXCEPT { return __ptr_.second(); }
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {
    return __ptr_.first() != nullptr;
  }

  _LIBCPP_INLINE_VISIBILITY
  pointer release() _NOEXCEPT {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  _LIBCPP_INLINE_VISIBILITY
      typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type
      reset(_Pp __p) _NOEXCEPT {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  _LIBCPP_INLINE_VISIBILITY
  void reset(nullptr_t = nullptr) _NOEXCEPT {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  _LIBCPP_INLINE_VISIBILITY
  void swap(hq_unique_ptr& __u) _NOEXCEPT { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp>
inline _LIBCPP_INLINE_VISIBILITY
    typename enable_if<__is_swappable<_Dp>::value, void>::type
    swap(hq_unique_ptr<_Tp, _Dp>& __x, hq_unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator==(const hq_unique_ptr<_T1, _D1>& __x,
           const hq_unique_ptr<_T2, _D2>& __y) {
  return __x.get() == __y.get();
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator!=(const hq_unique_ptr<_T1, _D1>& __x,
           const hq_unique_ptr<_T2, _D2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<(const hq_unique_ptr<_T1, _D1>& __x,
          const hq_unique_ptr<_T2, _D2>& __y) {
  typedef typename hq_unique_ptr<_T1, _D1>::pointer _P1;
  typedef typename hq_unique_ptr<_T2, _D2>::pointer _P2;
  typedef typename common_type<_P1, _P2>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>(const hq_unique_ptr<_T1, _D1>& __x,
          const hq_unique_ptr<_T2, _D2>& __y) {
  return __y < __x;
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<=(const hq_unique_ptr<_T1, _D1>& __x,
           const hq_unique_ptr<_T2, _D2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _D1, class _T2, class _D2>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>=(const hq_unique_ptr<_T1, _D1>& __x,
           const hq_unique_ptr<_T2, _D2>& __y) {
  return !(__x < __y);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator==(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT {
  return !__x;
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator==(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) _NOEXCEPT {
  return !__x;
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator!=(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator!=(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) _NOEXCEPT {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) {
  typedef typename hq_unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) {
  typedef typename hq_unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return nullptr < __x;
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) {
  return __x < nullptr;
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<=(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(nullptr < __x);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<=(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>=(const hq_unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>=(nullptr_t, const hq_unique_ptr<_T1, _D1>& __x) {
  return !(nullptr < __x);
}

#if _LIBCPP_STD_VER > 11

template <class _Tp>
struct __hq_unique_if {
  typedef hq_unique_ptr<_Tp> __unique_single;
};

template <class _Tp>
struct __hq_unique_if<_Tp[]> {
  typedef hq_unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template <class _Tp, size_t _Np>
struct __hq_unique_if<_Tp[_Np]> {
  typedef void __unique_array_known_bound;
};

template <class _Tp, class... _Args>
inline _LIBCPP_INLINE_VISIBILITY typename __hq_unique_if<_Tp>::__unique_single
make_hq_unique(_Args&&... __args) {
  return hq_unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
    typename __hq_unique_if<_Tp>::__unique_array_unknown_bound
    make_hq_unique(size_t __n) {
  typedef typename remove_extent<_Tp>::type _Up;
  return hq_unique_ptr<_Tp>(new _Up[__n]());
}

template <class _Tp, class... _Args>
typename __hq_unique_if<_Tp>::__unique_array_known_bound
make_hq_unique(_Args&&...) = delete;

#endif // _LIBCPP_STD_VER > 11

template <class _Tp, class _Dp>
#ifdef _LIBCPP_CXX03_LANG
struct _LIBCPP_TEMPLATE_VIS hash<hq_unique_ptr<_Tp, _Dp> >
#else
struct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<
    hq_unique_ptr<_Tp, _Dp>, typename hq_unique_ptr<_Tp, _Dp>::pointer> >
#endif
{
  typedef hq_unique_ptr<_Tp, _Dp> argument_type;
  typedef size_t result_type;
  _LIBCPP_INLINE_VISIBILITY
  result_type operator()(const argument_type& __ptr) const {
    typedef typename argument_type::pointer pointer;
    return hash<pointer>()(__ptr.get());
  }
};

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _Tp
__libcpp_hq_atomic_refcount_increment(_Tp& __t) _NOEXCEPT {
  __hq_pointer_check(reinterpret_cast<const void**>(const_cast<long*>(__t.p())),
                     reinterpret_cast<void*>(*__t.p()));
#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) &&                             \
    !defined(_LIBCPP_HAS_NO_THREADS)
  auto v = __atomic_add_fetch(__t.p(), 1, __ATOMIC_RELAXED);
#else
  auto v = __t += 1;
#endif
  __hq_pointer_define(
      reinterpret_cast<const void**>(const_cast<long*>(__t.p())),
      reinterpret_cast<void*>(v), false);
  return v;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _Tp
__libcpp_hq_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT {
  __hq_pointer_check(reinterpret_cast<const void**>(const_cast<long*>(__t.p())),
                     reinterpret_cast<void*>(*__t.p()));
#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) &&                             \
    !defined(_LIBCPP_HAS_NO_THREADS)
  auto v = __atomic_add_fetch(__t.p(), -1, __ATOMIC_ACQ_REL);
#else
  auto v = __t += 1;
#endif
  __hq_pointer_define(
      reinterpret_cast<const void**>(const_cast<long*>(__t.p())),
      reinterpret_cast<void*>(v), false);
  return v;
}

class _LIBCPP_EXCEPTION_ABI bad_hq_weak_ptr : public std::exception {
public:
  virtual ~bad_hq_weak_ptr() _NOEXCEPT;
  virtual const char* what() const _NOEXCEPT;
};

_LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY void
__throw_bad_hq_weak_ptr() {
#ifndef _LIBCPP_NO_EXCEPTIONS
  throw bad_hq_weak_ptr();
#else
  _VSTD::abort();
#endif
}

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS hq_weak_ptr;

class _LIBCPP_TYPE_VIS __hq_shared_count {
  __hq_shared_count(const __hq_shared_count&);
  __hq_shared_count& operator=(const __hq_shared_count&);

protected:
  hq_wrapper<long> __shared_owners_;
  virtual ~__hq_shared_count();

private:
  virtual void __on_zero_shared() _NOEXCEPT = 0;

public:
  _LIBCPP_INLINE_VISIBILITY
  explicit __hq_shared_count(long __refs = 0) _NOEXCEPT
      : __shared_owners_(__refs) {}

#if defined(_LIBCPP_BUILDING_LIBRARY) &&                                       \
    defined(                                                                   \
        _LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
  void __add_shared() _NOEXCEPT;
  bool __release_shared() _NOEXCEPT;
#else
  _LIBCPP_INLINE_VISIBILITY
  void __add_shared() _NOEXCEPT {
    __libcpp_hq_atomic_refcount_increment(__shared_owners_);
  }
  _LIBCPP_INLINE_VISIBILITY
  bool __release_shared() _NOEXCEPT {
    if (__libcpp_hq_atomic_refcount_decrement(__shared_owners_) == -1) {
      __on_zero_shared();
      return true;
    }
    return false;
  }
#endif
  _LIBCPP_INLINE_VISIBILITY
  long use_count() const _NOEXCEPT {
    auto v = __libcpp_relaxed_load(__shared_owners_.p());
    __hq_pointer_check(
        reinterpret_cast<const void**>(const_cast<long*>(__shared_owners_.p())),
        reinterpret_cast<void*>(v));
    return v + 1;
  }
};

class _LIBCPP_TYPE_VIS __hq_shared_weak_count : private __hq_shared_count {
  hq_wrapper<long> __shared_weak_owners_;

public:
  _LIBCPP_INLINE_VISIBILITY
  explicit __hq_shared_weak_count(long __refs = 0) _NOEXCEPT
      : __hq_shared_count(__refs),
        __shared_weak_owners_(__refs) {}

protected:
  virtual ~__hq_shared_weak_count();

public:
#if defined(_LIBCPP_BUILDING_LIBRARY) &&                                       \
    defined(                                                                   \
        _LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
  void __add_shared() _NOEXCEPT;
  void __add_weak() _NOEXCEPT;
  void __release_shared() _NOEXCEPT;
#else
  _LIBCPP_INLINE_VISIBILITY
  void __add_shared() _NOEXCEPT { __hq_shared_count::__add_shared(); }
  _LIBCPP_INLINE_VISIBILITY
  void __add_weak() _NOEXCEPT {
    __libcpp_hq_atomic_refcount_increment(__shared_weak_owners_);
  }
  _LIBCPP_INLINE_VISIBILITY
  void __release_shared() _NOEXCEPT {
    if (__hq_shared_count::__release_shared())
      __release_weak();
  }
#endif
  void __release_weak() _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  long use_count() const _NOEXCEPT { return __hq_shared_count::use_count(); }
  __hq_shared_weak_count* lock() _NOEXCEPT;

  // Define the function out only if we build static libc++ without RTTI.
  // Otherwise we may break clients who need to compile their projects with
  // -fno-rtti and yet link against a libc++.dylib compiled
  // without -fno-rtti.
#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)
  virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;
#endif
private:
  virtual void __on_zero_shared_weak() _NOEXCEPT = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __hq_shared_ptr_pointer : public __hq_shared_weak_count {
  __compressed_pair<__compressed_pair<hq_wrapper<_Tp>, _Dp>, _Alloc> __data_;

public:
  _LIBCPP_INLINE_VISIBILITY
  __hq_shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
      : __data_(__compressed_pair<hq_wrapper<_Tp>, _Dp>(__p, _VSTD::move(__d)),
                _VSTD::move(__a)) {}

#ifndef _LIBCPP_NO_RTTI
  virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;
#endif

private:
  virtual void __on_zero_shared() _NOEXCEPT;
  virtual void __on_zero_shared_weak() _NOEXCEPT;
};

#ifndef _LIBCPP_NO_RTTI

template <class _Tp, class _Dp, class _Alloc>
const void* __hq_shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(
    const type_info& __t) const _NOEXCEPT {
  return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second())
                            : nullptr;
}

#endif // _LIBCPP_NO_RTTI

template <class _Tp, class _Dp, class _Alloc>
void __hq_shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT {
  __data_.first().second()(__data_.first().first());
  __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void __hq_shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak()
    _NOEXCEPT {
  typedef
      typename __allocator_traits_rebind<_Alloc, __hq_shared_ptr_pointer>::type
          _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;

  _Al __a(__data_.second());
  __data_.second().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __hq_shared_ptr_emplace : public __hq_shared_weak_count {
  __compressed_pair<_Alloc, hq_wrapper<_Tp> > __data_;

public:
#ifndef _LIBCPP_HAS_NO_VARIADICS

  _LIBCPP_INLINE_VISIBILITY
  __hq_shared_ptr_emplace(_Alloc __a) : __data_(_VSTD::move(__a)) {}

  template <class... _Args>
  _LIBCPP_INLINE_VISIBILITY __hq_shared_ptr_emplace(_Alloc __a,
                                                    _Args&&... __args)
      : __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),
                _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}

#else // _LIBCPP_HAS_NO_VARIADICS

  _LIBCPP_INLINE_VISIBILITY
  __hq_shared_ptr_emplace(_Alloc __a) : __data_(__a) {}

  template <class _A0>
  _LIBCPP_INLINE_VISIBILITY __hq_shared_ptr_emplace(_Alloc __a, _A0& __a0)
      : __data_(__a, _Tp(__a0)) {}

  template <class _A0, class _A1>
  _LIBCPP_INLINE_VISIBILITY __hq_shared_ptr_emplace(_Alloc __a, _A0& __a0,
                                                    _A1& __a1)
      : __data_(__a, _Tp(__a0, __a1)) {}

  template <class _A0, class _A1, class _A2>
  _LIBCPP_INLINE_VISIBILITY __hq_shared_ptr_emplace(_Alloc __a, _A0& __a0,
                                                    _A1& __a1, _A2& __a2)
      : __data_(__a, _Tp(__a0, __a1, __a2)) {}

#endif // _LIBCPP_HAS_NO_VARIADICS

private:
  virtual void __on_zero_shared() _NOEXCEPT;
  virtual void __on_zero_shared_weak() _NOEXCEPT;

public:
  _LIBCPP_INLINE_VISIBILITY
  _Tp* get() _NOEXCEPT { return _VSTD::addressof(__data_.second()); }
};

template <class _Tp, class _Alloc>
void __hq_shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT {
  __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void __hq_shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT {
  typedef
      typename __allocator_traits_rebind<_Alloc, __hq_shared_ptr_emplace>::type
          _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;
  _Al __a(__data_.first());
  __data_.first().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __hq_shared_ptr_dummy_rebind_allocator_type;
template <>
class _LIBCPP_TEMPLATE_VIS
    allocator<__hq_shared_ptr_dummy_rebind_allocator_type> {
public:
  template <class _Other>
  struct rebind {
    typedef allocator<_Other> other;
  };
};

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS hq_enable_shared_from_this;

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS hq_shared_ptr {
public:
  typedef _Tp element_type;

#if _LIBCPP_STD_VER > 14
  typedef hq_weak_ptr<_Tp> weak_type;
#endif
private:
  hq_wrapper<element_type*> __ptr_;
  __hq_shared_weak_count* __cntrl_;

  struct __nat {
    int __for_bool_;
  };

public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR hq_shared_ptr() _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR hq_shared_ptr(nullptr_t) _NOEXCEPT;
  template <class _Yp>
  explicit hq_shared_ptr(
      _Yp* __p, typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat());
  template <class _Yp, class _Dp>
  hq_shared_ptr(_Yp* __p, _Dp __d,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat());
  template <class _Yp, class _Dp, class _Alloc>
  hq_shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat());
  template <class _Dp>
  hq_shared_ptr(nullptr_t __p, _Dp __d);
  template <class _Dp, class _Alloc>
  hq_shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY hq_shared_ptr(const hq_shared_ptr<_Yp>& __r,
                                          element_type* __p) _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr(const hq_shared_ptr& __r) _NOEXCEPT;
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr(const hq_shared_ptr<_Yp>& __r,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat()) _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr(hq_shared_ptr&& __r) _NOEXCEPT;
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr(hq_shared_ptr<_Yp>&& __r,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat()) _NOEXCEPT;
#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES
  template <class _Yp>
  explicit hq_shared_ptr(
      const hq_weak_ptr<_Yp>& __r,
      typename enable_if<is_convertible<_Yp*, element_type*>::value,
                         __nat>::type = __nat());
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  template <class _Yp>
  hq_shared_ptr(hq_auto_ptr<_Yp>&& __r,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat());
#else
  template <class _Yp>
  hq_shared_ptr(hq_auto_ptr<_Yp> __r,
                typename enable_if<is_convertible<_Yp*, element_type*>::value,
                                   __nat>::type = __nat());
#endif
#endif
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  template <class _Yp, class _Dp>
  hq_shared_ptr(
      hq_unique_ptr<_Yp, _Dp>&&,
      typename enable_if<
          !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
              is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                             element_type*>::value,
          __nat>::type = __nat());
  template <class _Yp, class _Dp>
  hq_shared_ptr(
      hq_unique_ptr<_Yp, _Dp>&&,
      typename enable_if<
          is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
              is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                             element_type*>::value,
          __nat>::type = __nat());
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
  template <class _Yp, class _Dp>
  hq_shared_ptr(
      hq_unique_ptr<_Yp, _Dp>,
      typename enable_if<
          !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
              is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                             element_type*>::value,
          __nat>::type = __nat());
  template <class _Yp, class _Dp>
  hq_shared_ptr(
      hq_unique_ptr<_Yp, _Dp>,
      typename enable_if<
          is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
              is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                             element_type*>::value,
          __nat>::type = __nat());
#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

  ~hq_shared_ptr();

  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr& operator=(const hq_shared_ptr& __r) _NOEXCEPT;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value,
                     hq_shared_ptr&>::type _LIBCPP_INLINE_VISIBILITY
  operator=(const hq_shared_ptr<_Yp>& __r) _NOEXCEPT;
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr& operator=(hq_shared_ptr&& __r) _NOEXCEPT;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value,
                     hq_shared_ptr<_Tp>&>::type _LIBCPP_INLINE_VISIBILITY
  operator=(hq_shared_ptr<_Yp>&& __r);
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY
      typename enable_if<!is_array<_Yp>::value &&
                             is_convertible<_Yp*, element_type*>::value,
                         hq_shared_ptr>::type&
      operator=(hq_auto_ptr<_Yp>&& __r);
#endif
#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY
      typename enable_if<!is_array<_Yp>::value &&
                             is_convertible<_Yp*, element_type*>::value,
                         hq_shared_ptr&>::type
      operator=(hq_auto_ptr<_Yp> __r);
#endif
#endif
  template <class _Yp, class _Dp>
  typename enable_if<
      !is_array<_Yp>::value &&
          is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                         element_type*>::value,
      hq_shared_ptr&>::type
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
      _LIBCPP_INLINE_VISIBILITY
      operator=(hq_unique_ptr<_Yp, _Dp>&& __r);
#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES
      _LIBCPP_INLINE_VISIBILITY
      operator=(hq_unique_ptr<_Yp, _Dp> __r);
#endif

  _LIBCPP_INLINE_VISIBILITY
  void swap(hq_shared_ptr& __r) _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  void reset() _NOEXCEPT;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value, void>::type
      _LIBCPP_INLINE_VISIBILITY
      reset(_Yp* __p);
  template <class _Yp, class _Dp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value, void>::type
      _LIBCPP_INLINE_VISIBILITY
      reset(_Yp* __p, _Dp __d);
  template <class _Yp, class _Dp, class _Alloc>
  typename enable_if<is_convertible<_Yp*, element_type*>::value, void>::type
      _LIBCPP_INLINE_VISIBILITY
      reset(_Yp* __p, _Dp __d, _Alloc __a);

  _LIBCPP_INLINE_VISIBILITY
  element_type* get() const _NOEXCEPT { return __ptr_; }
  _LIBCPP_INLINE_VISIBILITY
  typename add_lvalue_reference<element_type>::type
  operator*() const _NOEXCEPT {
    return *__ptr_;
  }
  _LIBCPP_INLINE_VISIBILITY
  element_type* operator->() const _NOEXCEPT { return __ptr_; }
  _LIBCPP_INLINE_VISIBILITY
  long use_count() const _NOEXCEPT {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  _LIBCPP_INLINE_VISIBILITY
  bool unique() const _NOEXCEPT { return use_count() == 1; }
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT { return get() != 0; }
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY bool
  owner_before(hq_shared_ptr<_Up> const& __p) const _NOEXCEPT {
    return __cntrl_ < __p.__cntrl_;
  }
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY bool
  owner_before(hq_weak_ptr<_Up> const& __p) const _NOEXCEPT {
    return __cntrl_ < __p.__cntrl_;
  }
  _LIBCPP_INLINE_VISIBILITY
  bool __owner_equivalent(const hq_shared_ptr& __p) const {
    return __cntrl_ == __p.__cntrl_;
  }

#ifndef _LIBCPP_NO_RTTI
  template <class _Dp>
  _LIBCPP_INLINE_VISIBILITY _Dp* __get_deleter() const _NOEXCEPT {
    return static_cast<_Dp*>(
        __cntrl_ ? const_cast<void*>(__cntrl_->__get_deleter(typeid(_Dp)))
                 : nullptr);
  }
#endif // _LIBCPP_NO_RTTI

  template <class _Yp, class _CntrlBlk>
  static hq_shared_ptr<_Tp> __create_with_control_block(_Yp* __p,
                                                        _CntrlBlk* __cntrl) {
    hq_shared_ptr<_Tp> __r;
    __r.__ptr_ = __p;
    __r.__cntrl_ = __cntrl;
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
  }

  template <class _Alloc, class... _Args>
  static hq_shared_ptr<_Tp> allocate_shared(const _Alloc& __a,
                                            _Args&&... __args);

private:
  template <class _Yp, bool = is_function<_Yp>::value>
  struct __hq_shared_ptr_default_allocator {
    typedef allocator<_Yp> type;
  };

  template <class _Yp>
  struct __hq_shared_ptr_default_allocator<_Yp, true> {
    typedef allocator<__hq_shared_ptr_dummy_rebind_allocator_type> type;
  };

  template <class _Yp, class _OrigPtr>
  _LIBCPP_INLINE_VISIBILITY typename enable_if<
      is_convertible<_OrigPtr*, const hq_enable_shared_from_this<_Yp>*>::value,
      void>::type
  __enable_weak_this(const hq_enable_shared_from_this<_Yp>* __e,
                     _OrigPtr* __ptr) _NOEXCEPT {
    typedef typename remove_cv<_Yp>::type _RawYp;
    if (__e && __e->__weak_this_.expired()) {
      __e->__weak_this_ = hq_shared_ptr<_RawYp>(
          *this, const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
    }
  }

  _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT {}

  template <class _Up>
  friend class _LIBCPP_TEMPLATE_VIS hq_shared_ptr;
  template <class _Up>
  friend class _LIBCPP_TEMPLATE_VIS hq_weak_ptr;
};

template <class _Tp>
inline _LIBCPP_CONSTEXPR hq_shared_ptr<_Tp>::hq_shared_ptr() _NOEXCEPT
    : __ptr_(0),
      __cntrl_(0) {}

template <class _Tp>
inline _LIBCPP_CONSTEXPR hq_shared_ptr<_Tp>::hq_shared_ptr(nullptr_t) _NOEXCEPT
    : __ptr_(0),
      __cntrl_(0) {}

template <class _Tp>
template <class _Yp>
hq_shared_ptr<_Tp>::hq_shared_ptr(
    _Yp* __p,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p) {
  hq_unique_ptr<_Yp> __hold(__p);
  typedef typename __hq_shared_ptr_default_allocator<_Yp>::type _AllocT;
  typedef __hq_shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT> _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
  __hold.release();
  __enable_weak_this(__p, __p);
}

template <class _Tp>
template <class _Yp, class _Dp>
hq_shared_ptr<_Tp>::hq_shared_ptr(
    _Yp* __p, _Dp __d,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p) {
#ifndef _LIBCPP_NO_EXCEPTIONS
  try {
#endif // _LIBCPP_NO_EXCEPTIONS
    typedef typename __hq_shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __hq_shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
    __enable_weak_this(__p, __p);
#ifndef _LIBCPP_NO_EXCEPTIONS
  } catch (...) {
    __d(__p);
    throw;
  }
#endif // _LIBCPP_NO_EXCEPTIONS
}

template <class _Tp>
template <class _Dp>
hq_shared_ptr<_Tp>::hq_shared_ptr(nullptr_t __p, _Dp __d) : __ptr_(0) {
#ifndef _LIBCPP_NO_EXCEPTIONS
  try {
#endif // _LIBCPP_NO_EXCEPTIONS
    typedef typename __hq_shared_ptr_default_allocator<_Tp>::type _AllocT;
    typedef __hq_shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
#ifndef _LIBCPP_NO_EXCEPTIONS
  } catch (...) {
    __d(__p);
    throw;
  }
#endif // _LIBCPP_NO_EXCEPTIONS
}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
hq_shared_ptr<_Tp>::hq_shared_ptr(
    _Yp* __p, _Dp __d, _Alloc __a,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p) {
#ifndef _LIBCPP_NO_EXCEPTIONS
  try {
#endif // _LIBCPP_NO_EXCEPTIONS
    typedef __hq_shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    hq_unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void*>(_VSTD::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = _VSTD::addressof(*__hold2.release());
    __enable_weak_this(__p, __p);
#ifndef _LIBCPP_NO_EXCEPTIONS
  } catch (...) {
    __d(__p);
    throw;
  }
#endif // _LIBCPP_NO_EXCEPTIONS
}

template <class _Tp>
template <class _Dp, class _Alloc>
hq_shared_ptr<_Tp>::hq_shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0) {
#ifndef _LIBCPP_NO_EXCEPTIONS
  try {
#endif // _LIBCPP_NO_EXCEPTIONS
    typedef __hq_shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    hq_unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void*>(_VSTD::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = _VSTD::addressof(*__hold2.release());
#ifndef _LIBCPP_NO_EXCEPTIONS
  } catch (...) {
    __d(__p);
    throw;
  }
#endif // _LIBCPP_NO_EXCEPTIONS
}

template <class _Tp>
template <class _Yp>
inline hq_shared_ptr<_Tp>::hq_shared_ptr(const hq_shared_ptr<_Yp>& __r,
                                         element_type* __p) _NOEXCEPT
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
inline hq_shared_ptr<_Tp>::hq_shared_ptr(const hq_shared_ptr& __r) _NOEXCEPT
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
template <class _Yp>
inline hq_shared_ptr<_Tp>::hq_shared_ptr(
    const hq_shared_ptr<_Yp>& __r,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    _NOEXCEPT : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
inline hq_shared_ptr<_Tp>::hq_shared_ptr(hq_shared_ptr&& __r) _NOEXCEPT
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_shared_ptr<_Yp>&& __r,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    _NOEXCEPT : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp>
template <class _Yp>
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_auto_ptr<_Yp>&& __r,
#else
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_auto_ptr<_Yp> __r,
#endif
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get()) {
  typedef __hq_shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> >
      _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
  __enable_weak_this(__r.get(), __r.get());
  __r.release();
}
#endif

template <class _Tp>
template <class _Yp, class _Dp>
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_unique_ptr<_Yp, _Dp>&& __r,
#else
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_unique_ptr<_Yp, _Dp> __r,
#endif
    typename enable_if<
        !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                           element_type*>::value,
        __nat>::type)
    : __ptr_(__r.get()) {
#if _LIBCPP_STD_VER > 11
  if (__ptr_ == nullptr)
    __cntrl_ = nullptr;
  else
#endif
  {
    typedef typename __hq_shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __hq_shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}

template <class _Tp>
template <class _Yp, class _Dp>
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_unique_ptr<_Yp, _Dp>&& __r,
#else
hq_shared_ptr<_Tp>::hq_shared_ptr(
    hq_unique_ptr<_Yp, _Dp> __r,
#endif
    typename enable_if<
        is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                           element_type*>::value,
        __nat>::type)
    : __ptr_(__r.get()) {
#if _LIBCPP_STD_VER > 11
  if (__ptr_ == nullptr)
    __cntrl_ = nullptr;
  else
#endif
  {
    typedef typename __hq_shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __hq_shared_ptr_pointer<
        _Yp*, reference_wrapper<typename remove_reference<_Dp>::type>, _AllocT>
        _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}

template <class _Tp>
template <class _Alloc, class... _Args>
hq_shared_ptr<_Tp> hq_shared_ptr<_Tp>::allocate_shared(const _Alloc& __a,
                                                       _Args&&... __args) {
  static_assert(is_constructible<_Tp, _Args...>::value,
                "Can't construct object in allocate_shared");
  typedef __hq_shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
  typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
  typedef __allocator_destructor<_A2> _D2;
  _A2 __a2(__a);
  hq_unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (static_cast<void*>(_VSTD::addressof(*__hold2.get())))
      _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);
  hq_shared_ptr<_Tp> __r;
  __r.__ptr_ = __hold2.get()->get();
  __r.__cntrl_ = _VSTD::addressof(*__hold2.release());
  __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
  return __r;
}

template <class _Tp>
hq_shared_ptr<_Tp>::~hq_shared_ptr() {
  if (__cntrl_)
    __cntrl_->__release_shared();
}

template <class _Tp>
inline hq_shared_ptr<_Tp>&
hq_shared_ptr<_Tp>::operator=(const hq_shared_ptr& __r) _NOEXCEPT {
  hq_shared_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp>&>::type
hq_shared_ptr<_Tp>::operator=(const hq_shared_ptr<_Yp>& __r) _NOEXCEPT {
  hq_shared_ptr(__r).swap(*this);
  return *this;
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
inline hq_shared_ptr<_Tp>&
hq_shared_ptr<_Tp>::operator=(hq_shared_ptr&& __r) _NOEXCEPT {
  hq_shared_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp>&>::type
hq_shared_ptr<_Tp>::operator=(hq_shared_ptr<_Yp>&& __r) {
  hq_shared_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp>
template <class _Yp>
inline typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp> >::type&
hq_shared_ptr<_Tp>::operator=(hq_auto_ptr<_Yp>&& __r) {
  hq_shared_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}
#endif

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                       typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp>&>::type
hq_shared_ptr<_Tp>::operator=(hq_unique_ptr<_Yp, _Dp>&& __r) {
  hq_shared_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

#else // _LIBCPP_HAS_NO_RVALUE_REFERENCES

#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp>
template <class _Yp>
inline _LIBCPP_INLINE_VISIBILITY typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp>&>::type
hq_shared_ptr<_Tp>::operator=(hq_auto_ptr<_Yp> __r) {
  hq_shared_ptr(__r).swap(*this);
  return *this;
}
#endif

template <class _Tp>
template <class _Yp, class _Dp>
inline _LIBCPP_INLINE_VISIBILITY typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<typename hq_unique_ptr<_Yp, _Dp>::pointer,
                       typename hq_shared_ptr<_Tp>::element_type*>::value,
    hq_shared_ptr<_Tp>&>::type
hq_shared_ptr<_Tp>::operator=(hq_unique_ptr<_Yp, _Dp> __r) {
  hq_shared_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
inline void hq_shared_ptr<_Tp>::swap(hq_shared_ptr& __r) _NOEXCEPT {
  _VSTD::swap(__ptr_, __r.__ptr_);
  _VSTD::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline void hq_shared_ptr<_Tp>::reset() _NOEXCEPT {
  hq_shared_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    void>::type
hq_shared_ptr<_Tp>::reset(_Yp* __p) {
  hq_shared_ptr(__p).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<
    is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    void>::type
hq_shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d) {
  hq_shared_ptr(__p, __d).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
inline typename enable_if<
    is_convertible<_Yp*, typename hq_shared_ptr<_Tp>::element_type*>::value,
    void>::type
hq_shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a) {
  hq_shared_ptr(__p, __d, __a).swap(*this);
}

template <class _Tp, class... _Args>
inline _LIBCPP_INLINE_VISIBILITY
    typename enable_if<!is_array<_Tp>::value, hq_shared_ptr<_Tp> >::type
    make_hq_shared(_Args&&... __args) {
  static_assert(is_constructible<_Tp, _Args...>::value,
                "Can't construct object in make_hq_shared");
  typedef __hq_shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
  typedef allocator<_CntrlBlk> _A2;
  typedef __allocator_destructor<_A2> _D2;

  _A2 __a2;
  hq_unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);

  _Tp* __ptr = __hold2.get()->get();
  return hq_shared_ptr<_Tp>::__create_with_control_block(__ptr,
                                                         __hold2.release());
}

template <class _Tp, class _Alloc, class... _Args>
inline _LIBCPP_INLINE_VISIBILITY
    typename enable_if<!is_array<_Tp>::value, hq_shared_ptr<_Tp> >::type
    allocate_shared(const _Alloc& __a, _Args&&... __args) {
  return hq_shared_ptr<_Tp>::allocate_shared(__a,
                                             _VSTD::forward<_Args>(__args)...);
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator==(const hq_shared_ptr<_Tp>& __x,
           const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
  return __x.get() == __y.get();
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator!=(const hq_shared_ptr<_Tp>& __x,
           const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
  return !(__x == __y);
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<(const hq_shared_ptr<_Tp>& __x,
          const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
#if _LIBCPP_STD_VER <= 11
  typedef typename common_type<_Tp*, _Up*>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
#else
  return less<>()(__x.get(), __y.get());
#endif
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>(const hq_shared_ptr<_Tp>& __x,
          const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
  return __y < __x;
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<=(const hq_shared_ptr<_Tp>& __x,
           const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
  return !(__y < __x);
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>=(const hq_shared_ptr<_Tp>& __x,
           const hq_shared_ptr<_Up>& __y) _NOEXCEPT {
  return !(__x < __y);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator==(const hq_shared_ptr<_Tp>& __x,
                                                 nullptr_t) _NOEXCEPT {
  return !__x;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator==(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return !__x;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const hq_shared_ptr<_Tp>& __x,
                                                 nullptr_t) _NOEXCEPT {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator!=(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator<(const hq_shared_ptr<_Tp>& __x,
                                                nullptr_t) _NOEXCEPT {
  return less<_Tp*>()(__x.get(), nullptr);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return less<_Tp*>()(nullptr, __x.get());
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator>(const hq_shared_ptr<_Tp>& __x,
                                                nullptr_t) _NOEXCEPT {
  return nullptr < __x;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return __x < nullptr;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const hq_shared_ptr<_Tp>& __x,
                                                 nullptr_t) _NOEXCEPT {
  return !(nullptr < __x);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator<=(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return !(__x < nullptr);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const hq_shared_ptr<_Tp>& __x,
                                                 nullptr_t) _NOEXCEPT {
  return !(__x < nullptr);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
operator>=(nullptr_t, const hq_shared_ptr<_Tp>& __x) _NOEXCEPT {
  return !(nullptr < __x);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY void swap(hq_shared_ptr<_Tp>& __x,
                                           hq_shared_ptr<_Tp>& __y) _NOEXCEPT {
  __x.swap(__y);
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
    typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                       hq_shared_ptr<_Tp> >::type
    static_pointer_cast(const hq_shared_ptr<_Up>& __r) _NOEXCEPT {
  return hq_shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
    typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                       hq_shared_ptr<_Tp> >::type
    dynamic_pointer_cast(const hq_shared_ptr<_Up>& __r) _NOEXCEPT {
  _Tp* __p = dynamic_cast<_Tp*>(__r.get());
  return __p ? hq_shared_ptr<_Tp>(__r, __p) : hq_shared_ptr<_Tp>();
}

template <class _Tp, class _Up>
typename enable_if<is_array<_Tp>::value == is_array<_Up>::value,
                   hq_shared_ptr<_Tp> >::type
const_pointer_cast(const hq_shared_ptr<_Up>& __r) _NOEXCEPT {
  typedef typename remove_extent<_Tp>::type _RTp;
  return hq_shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}

#ifndef _LIBCPP_NO_RTTI

template <class _Dp, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _Dp*
get_deleter(const hq_shared_ptr<_Tp>& __p) _NOEXCEPT {
  return __p.template __get_deleter<_Dp>();
}

#endif // _LIBCPP_NO_RTTI

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS hq_weak_ptr {
public:
  typedef _Tp element_type;

private:
  hq_wrapper<element_type*> __ptr_;
  __hq_shared_weak_count* __cntrl_;

public:
  _LIBCPP_INLINE_VISIBILITY
  _LIBCPP_CONSTEXPR hq_weak_ptr() _NOEXCEPT;
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY hq_weak_ptr(
      hq_shared_ptr<_Yp> const& __r,
      typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type =
          0) _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr(hq_weak_ptr const& __r) _NOEXCEPT;
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY hq_weak_ptr(
      hq_weak_ptr<_Yp> const& __r,
      typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type =
          0) _NOEXCEPT;

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr(hq_weak_ptr&& __r) _NOEXCEPT;
  template <class _Yp>
  _LIBCPP_INLINE_VISIBILITY hq_weak_ptr(
      hq_weak_ptr<_Yp>&& __r,
      typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type =
          0) _NOEXCEPT;
#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES
  ~hq_weak_ptr();

  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr& operator=(hq_weak_ptr const& __r) _NOEXCEPT;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value,
                     hq_weak_ptr&>::type _LIBCPP_INLINE_VISIBILITY
  operator=(hq_weak_ptr<_Yp> const& __r) _NOEXCEPT;

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr& operator=(hq_weak_ptr&& __r) _NOEXCEPT;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value,
                     hq_weak_ptr&>::type _LIBCPP_INLINE_VISIBILITY
  operator=(hq_weak_ptr<_Yp>&& __r) _NOEXCEPT;

#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

  template <class _Yp>
  typename enable_if<is_convertible<_Yp*, element_type*>::value,
                     hq_weak_ptr&>::type _LIBCPP_INLINE_VISIBILITY
  operator=(hq_shared_ptr<_Yp> const& __r) _NOEXCEPT;

  _LIBCPP_INLINE_VISIBILITY
  void swap(hq_weak_ptr& __r) _NOEXCEPT;
  _LIBCPP_INLINE_VISIBILITY
  void reset() _NOEXCEPT;

  _LIBCPP_INLINE_VISIBILITY
  long use_count() const _NOEXCEPT {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  _LIBCPP_INLINE_VISIBILITY
  bool expired() const _NOEXCEPT {
    return __cntrl_ == 0 || __cntrl_->use_count() == 0;
  }
  hq_shared_ptr<_Tp> lock() const _NOEXCEPT;
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY bool
  owner_before(const hq_shared_ptr<_Up>& __r) const _NOEXCEPT {
    return __cntrl_ < __r.__cntrl_;
  }
  template <class _Up>
  _LIBCPP_INLINE_VISIBILITY bool
  owner_before(const hq_weak_ptr<_Up>& __r) const _NOEXCEPT {
    return __cntrl_ < __r.__cntrl_;
  }

  template <class _Up>
  friend class _LIBCPP_TEMPLATE_VIS hq_weak_ptr;
  template <class _Up>
  friend class _LIBCPP_TEMPLATE_VIS hq_shared_ptr;
};

template <class _Tp>
inline _LIBCPP_CONSTEXPR hq_weak_ptr<_Tp>::hq_weak_ptr() _NOEXCEPT
    : __ptr_(0),
      __cntrl_(0) {}

template <class _Tp>
inline hq_weak_ptr<_Tp>::hq_weak_ptr(hq_weak_ptr const& __r) _NOEXCEPT
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline hq_weak_ptr<_Tp>::hq_weak_ptr(
    hq_shared_ptr<_Yp> const& __r,
    typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
    _NOEXCEPT : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline hq_weak_ptr<_Tp>::hq_weak_ptr(
    hq_weak_ptr<_Yp> const& __r,
    typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
    _NOEXCEPT : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
inline hq_weak_ptr<_Tp>::hq_weak_ptr(hq_weak_ptr&& __r) _NOEXCEPT
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline hq_weak_ptr<_Tp>::hq_weak_ptr(
    hq_weak_ptr<_Yp>&& __r,
    typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
    _NOEXCEPT : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
hq_weak_ptr<_Tp>::~hq_weak_ptr() {
  if (__cntrl_)
    __cntrl_->__release_weak();
}

template <class _Tp>
inline hq_weak_ptr<_Tp>&
hq_weak_ptr<_Tp>::operator=(hq_weak_ptr const& __r) _NOEXCEPT {
  hq_weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp*, _Tp*>::value,
                          hq_weak_ptr<_Tp>&>::type
hq_weak_ptr<_Tp>::operator=(hq_weak_ptr<_Yp> const& __r) _NOEXCEPT {
  hq_weak_ptr(__r).swap(*this);
  return *this;
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
inline hq_weak_ptr<_Tp>&
hq_weak_ptr<_Tp>::operator=(hq_weak_ptr&& __r) _NOEXCEPT {
  hq_weak_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp*, _Tp*>::value,
                          hq_weak_ptr<_Tp>&>::type
hq_weak_ptr<_Tp>::operator=(hq_weak_ptr<_Yp>&& __r) _NOEXCEPT {
  hq_weak_ptr(_VSTD::move(__r)).swap(*this);
  return *this;
}

#endif // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp*, _Tp*>::value,
                          hq_weak_ptr<_Tp>&>::type
hq_weak_ptr<_Tp>::operator=(hq_shared_ptr<_Yp> const& __r) _NOEXCEPT {
  hq_weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline void hq_weak_ptr<_Tp>::swap(hq_weak_ptr& __r) _NOEXCEPT {
  _VSTD::swap(__ptr_, __r.__ptr_);
  _VSTD::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY void swap(hq_weak_ptr<_Tp>& __x,
                                           hq_weak_ptr<_Tp>& __y) _NOEXCEPT {
  __x.swap(__y);
}

template <class _Tp>
inline void hq_weak_ptr<_Tp>::reset() _NOEXCEPT {
  hq_weak_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
hq_shared_ptr<_Tp>::hq_shared_ptr(
    const hq_weak_ptr<_Yp>& __r,
    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_) {
  if (__cntrl_ == 0)
    __throw_bad_hq_weak_ptr();
}

template <class _Tp>
hq_shared_ptr<_Tp> hq_weak_ptr<_Tp>::lock() const _NOEXCEPT {
  hq_shared_ptr<_Tp> __r;
  __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
  if (__r.__cntrl_)
    __r.__ptr_ = __ptr_;
  return __r;
}

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS owner_less<hq_shared_ptr<_Tp> >
    : binary_function<hq_shared_ptr<_Tp>, hq_shared_ptr<_Tp>, bool> {
  typedef bool result_type;
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_shared_ptr<_Tp> const& __x,
                  hq_shared_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_shared_ptr<_Tp> const& __x,
                  hq_weak_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_weak_ptr<_Tp> const& __x,
                  hq_shared_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS owner_less<hq_weak_ptr<_Tp> >
    : binary_function<hq_weak_ptr<_Tp>, hq_weak_ptr<_Tp>, bool> {
  typedef bool result_type;
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_weak_ptr<_Tp> const& __x,
                  hq_weak_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_shared_ptr<_Tp> const& __x,
                  hq_weak_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
  _LIBCPP_INLINE_VISIBILITY
  bool operator()(hq_weak_ptr<_Tp> const& __x,
                  hq_shared_ptr<_Tp> const& __y) const _NOEXCEPT {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
class _LIBCPP_TEMPLATE_VIS hq_enable_shared_from_this {
  mutable hq_weak_ptr<_Tp> __weak_this_;

protected:
  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
  hq_enable_shared_from_this() _NOEXCEPT {}
  _LIBCPP_INLINE_VISIBILITY
  hq_enable_shared_from_this(hq_enable_shared_from_this const&) _NOEXCEPT {}
  _LIBCPP_INLINE_VISIBILITY
  hq_enable_shared_from_this&
  operator=(hq_enable_shared_from_this const&) _NOEXCEPT {
    return *this;
  }
  _LIBCPP_INLINE_VISIBILITY
  ~hq_enable_shared_from_this() {}

public:
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr<_Tp> shared_from_this() {
    return hq_shared_ptr<_Tp>(__weak_this_);
  }
  _LIBCPP_INLINE_VISIBILITY
  hq_shared_ptr<_Tp const> shared_from_this() const {
    return hq_shared_ptr<const _Tp>(__weak_this_);
  }

#if _LIBCPP_STD_VER > 14
  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr<_Tp> weak_from_this() _NOEXCEPT { return __weak_this_; }

  _LIBCPP_INLINE_VISIBILITY
  hq_weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT {
    return __weak_this_;
  }
#endif // _LIBCPP_STD_VER > 14

  template <class _Up>
  friend class hq_shared_ptr;
};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS hash<hq_shared_ptr<_Tp> > {
  typedef hq_shared_ptr<_Tp> argument_type;
  typedef size_t result_type;

  _LIBCPP_INLINE_VISIBILITY
  result_type operator()(const argument_type& __ptr) const _NOEXCEPT {
    return hash<_Tp*>()(__ptr.get());
  }
};

template <class _CharT, class _Traits, class _Yp>
inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, hq_shared_ptr<_Yp> const& __p);

#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY bool
atomic_is_lock_free(const hq_shared_ptr<_Tp>*) {
  return false;
}

template <class _Tp>
_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR hq_shared_ptr<_Tp>
atomic_load(const hq_shared_ptr<_Tp>* __p) {
  __sp_mut& __m = __get_sp_mut(__p);
  __m.lock();
  hq_shared_ptr<_Tp> __q = *__p;
  __m.unlock();
  return __q;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR hq_shared_ptr<_Tp>
    atomic_load_explicit(const hq_shared_ptr<_Tp>* __p, memory_order) {
  return atomic_load(__p);
}

template <class _Tp>
_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR void
atomic_store(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp> __r) {
  __sp_mut& __m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR void
atomic_store_explicit(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp> __r,
                      memory_order) {
  atomic_store(__p, __r);
}

template <class _Tp>
_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR hq_shared_ptr<_Tp>
atomic_exchange(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp> __r) {
  __sp_mut& __m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
  return __r;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
    _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR hq_shared_ptr<_Tp>
    atomic_exchange_explicit(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp> __r,
                             memory_order) {
  return atomic_exchange(__p, __r);
}

template <class _Tp>
_LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool
atomic_compare_exchange_strong(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp>* __v,
                               hq_shared_ptr<_Tp> __w) {
  hq_shared_ptr<_Tp> __temp;
  __sp_mut& __m = __get_sp_mut(__p);
  __m.lock();
  if (__p->__owner_equivalent(*__v)) {
    _VSTD::swap(__temp, *__p);
    *__p = __w;
    __m.unlock();
    return true;
  }
  _VSTD::swap(__temp, *__v);
  *__v = *__p;
  __m.unlock();
  return false;
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool
atomic_compare_exchange_weak(hq_shared_ptr<_Tp>* __p, hq_shared_ptr<_Tp>* __v,
                             hq_shared_ptr<_Tp> __w) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool
atomic_compare_exchange_strong_explicit(hq_shared_ptr<_Tp>* __p,
                                        hq_shared_ptr<_Tp>* __v,
                                        hq_shared_ptr<_Tp> __w, memory_order,
                                        memory_order) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool
atomic_compare_exchange_weak_explicit(hq_shared_ptr<_Tp>* __p,
                                      hq_shared_ptr<_Tp>* __v,
                                      hq_shared_ptr<_Tp> __w, memory_order,
                                      memory_order) {
  return atomic_compare_exchange_weak(__p, __v, __w);
}

#endif // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#if defined(_LIBCPP_HAS_PARALLEL_ALGORITHMS) && _LIBCPP_STD_VER >= 17
#include <__pstl_memory>
#endif

#endif // _LIBCPP_MEMORY
